{"version":3,"sources":["p5.collide2d.js"],"names":["console","log","p5","prototype","_collideDebug","collideDebug","debugMode","collideRectRect","x","y","w","h","x2","y2","w2","h2","collideRectCircle","rx","ry","rw","rh","cx","cy","diameter","testX","testY","distance","dist","collideCircleCircle","d","d2","collidePointCircle","collidePointEllipse","dx","dy","xx","yy","eyy","sqrt","abs","collidePointRect","pointX","pointY","xW","yW","collidePointLine","px","py","x1","y1","buffer","d1","lineLen","undefined","collideLineCircle","inside1","inside2","distX","distY","len","dot","pow","closestX","closestY","ellipse","collideLineLine","x3","y3","x4","y4","calcIntersection","intersection","uA","uB","intersectionX","intersectionY","collideLineRect","left","right","top","bottom","collidePointPoly","vertices","collision","next","current","length","vc","vn","collideCirclePoly","interior","collideRectPoly","inside","collideLinePoly","hit","collidePolyPoly","p1","p2","collidePointTriangle","areaOrig","area1","collidePointPoint","collidePointArc","ax","ay","arcRadius","arcHeading","arcAngle","point","createVector","arcPos","radius","rotate","pointToArc","copy","sub","angle","angleBetween"],"mappings":"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","file":"p5.collide2d.0903a939.js","sourceRoot":"../src","sourcesContent":["/*\nRepo: https://github.com/bmoren/p5.collide2D/\nCreated by http://benmoren.com\nSome functions and code modified version from http://www.jeffreythompson.org/collision-detection\nVersion 0.6 | Nov 28th, 2018\nCC BY-NC-SA 4.0\n*/\nconsole.log(\"### p5.collide ###\")\n\np5.prototype._collideDebug = false;\n\np5.prototype.collideDebug = function(debugMode){\n    _collideDebug = debugMode;\n}\n\n/*~++~+~+~++~+~++~++~+~+~ 2D ~+~+~++~+~++~+~+~+~+~+~+~+~+~+~+*/\n\np5.prototype.collideRectRect = function (x, y, w, h, x2, y2, w2, h2) {\n  //2d\n  //add in a thing to detect rectMode CENTER\n  if (x + w >= x2 &&    // r1 right edge past r2 left\n      x <= x2 + w2 &&    // r1 left edge past r2 right\n      y + h >= y2 &&    // r1 top edge past r2 bottom\n      y <= y2 + h2) {    // r1 bottom edge past r2 top\n        return true;\n  }\n  return false;\n};\n\np5.prototype.collideRectCircle = function (rx, ry, rw, rh, cx, cy, diameter) {\n  //2d\n  // temporary variables to set edges for testing\n  var testX = cx;\n  var testY = cy;\n\n  // which edge is closest?\n  if (cx < rx){         testX = rx       // left edge\n  }else if (cx > rx+rw){ testX = rx+rw  }   // right edge\n\n  if (cy < ry){         testY = ry       // top edge\n  }else if (cy > ry+rh){ testY = ry+rh }   // bottom edge\n\n  // // get distance from closest edges\n  var distance = this.dist(cx,cy,testX,testY)\n\n  // if the distance is less than the radius, collision!\n  if (distance <= diameter/2) {\n    return true;\n  }\n  return false;\n};\n\np5.prototype.collideCircleCircle = function (x, y,d, x2, y2, d2) {\n//2d\n  if( this.dist(x,y,x2,y2) <= (d/2)+(d2/2) ){\n    return true;\n  }\n  return false;\n};\n\np5.prototype.collidePointCircle = function (x, y, cx, cy, d) {\n//2d\nif( this.dist(x,y,cx,cy) <= d/2 ){\n  return true;\n}\nreturn false;\n};\n\np5.prototype.collidePointEllipse = function (x, y, cx, cy, dx, dy) {\n  //2d\n  var rx = dx/2, ry = dy/2;\n  // Discarding the points outside the bounding box\n  if (x > cx + rx || x < cx - rx ||y > cy + ry || y < cy - ry) {\n\t\treturn false;\n  }\n  // Compare the point to its equivalent on the ellipse\n  var xx = x - cx, yy = y - cy;\n  var eyy = ry * this.sqrt(this.abs(rx * rx - xx * xx)) / rx;\n  return yy <= eyy && yy >= -eyy;\n};\n\np5.prototype.collidePointRect = function (pointX, pointY, x, y, xW, yW) {\n//2d\nif (pointX >= x &&         // right of the left edge AND\n    pointX <= x + xW &&    // left of the right edge AND\n    pointY >= y &&         // below the top AND\n    pointY <= y + yW) {    // above the bottom\n        return true;\n}\nreturn false;\n};\n\np5.prototype.collidePointLine = function(px,py,x1,y1,x2,y2, buffer){\n  // get distance from the point to the two ends of the line\nvar d1 = this.dist(px,py, x1,y1);\nvar d2 = this.dist(px,py, x2,y2);\n\n// get the length of the line\nvar lineLen = this.dist(x1,y1, x2,y2);\n\n// since floats are so minutely accurate, add a little buffer zone that will give collision\nif (buffer === undefined){ buffer = 0.1; }   // higher # = less accurate\n\n// if the two distances are equal to the line's length, the point is on the line!\n// note we use the buffer here to give a range, rather than one #\nif (d1+d2 >= lineLen-buffer && d1+d2 <= lineLen+buffer) {\n  return true;\n}\nreturn false;\n}\n\np5.prototype.collideLineCircle = function( x1,  y1,  x2,  y2,  cx,  cy,  diameter) {\n  // is either end INSIDE the circle?\n  // if so, return true immediately\n  var inside1 = this.collidePointCircle(x1,y1, cx,cy,diameter);\n  var inside2 = this.collidePointCircle(x2,y2, cx,cy,diameter);\n  if (inside1 || inside2) return true;\n\n  // get length of the line\n  var distX = x1 - x2;\n  var distY = y1 - y2;\n  var len = this.sqrt( (distX*distX) + (distY*distY) );\n\n  // get dot product of the line and circle\n  var dot = ( ((cx-x1)*(x2-x1)) + ((cy-y1)*(y2-y1)) ) / this.pow(len,2);\n\n  // find the closest point on the line\n  var closestX = x1 + (dot * (x2-x1));\n  var closestY = y1 + (dot * (y2-y1));\n\n  // is this point actually on the line segment?\n  // if so keep going, but if not, return false\n  var onSegment = this.collidePointLine(closestX,closestY,x1,y1,x2,y2);\n  if (!onSegment) return false;\n\n  // draw a debug circle at the closest point on the line\n  if(this._collideDebug){\n    this.ellipse(closestX, closestY,10,10);\n  }\n\n  // get distance to closest point\n  distX = closestX - cx;\n  distY = closestY - cy;\n  var distance = this.sqrt( (distX*distX) + (distY*distY) );\n\n  if (distance <= diameter/2) {\n    return true;\n  }\n  return false;\n}\n\np5.prototype.collideLineLine = function(x1, y1, x2, y2, x3, y3, x4, y4,calcIntersection) {\n\n  var intersection;\n\n  // calculate the distance to intersection point\n  var uA = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));\n  var uB = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));\n\n  // if uA and uB are between 0-1, lines are colliding\n  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {\n\n    if(this._collideDebug || calcIntersection){\n      // calc the point where the lines meet\n      var intersectionX = x1 + (uA * (x2-x1));\n      var intersectionY = y1 + (uA * (y2-y1));\n    }\n\n    if(this._collideDebug){\n      this.ellipse(intersectionX,intersectionY,10,10);\n    }\n\n    if(calcIntersection){\n      intersection = {\n        \"x\":intersectionX,\n        \"y\":intersectionY\n      }\n      return intersection;\n    }else{\n      return true;\n    }\n  }\n  if(calcIntersection){\n    intersection = {\n      \"x\":false,\n      \"y\":false\n    }\n    return intersection;\n  }\n  return false;\n}\n\np5.prototype.collideLineRect = function(x1, y1, x2, y2, rx, ry, rw, rh, calcIntersection) {\n\n  // check if the line has hit any of the rectangle's sides. uses the collideLineLine function above\n  var left, right, top, bottom, intersection;\n\n  if(calcIntersection){\n     left =   this.collideLineLine(x1,y1,x2,y2, rx,ry,rx, ry+rh,true);\n     right =  this.collideLineLine(x1,y1,x2,y2, rx+rw,ry, rx+rw,ry+rh,true);\n     top =    this.collideLineLine(x1,y1,x2,y2, rx,ry, rx+rw,ry,true);\n     bottom = this.collideLineLine(x1,y1,x2,y2, rx,ry+rh, rx+rw,ry+rh,true);\n     intersection = {\n        \"left\" : left,\n        \"right\" : right,\n        \"top\" : top,\n        \"bottom\" : bottom\n    }\n  }else{\n    //return booleans\n     left =   this.collideLineLine(x1,y1,x2,y2, rx,ry,rx, ry+rh);\n     right =  this.collideLineLine(x1,y1,x2,y2, rx+rw,ry, rx+rw,ry+rh);\n     top =    this.collideLineLine(x1,y1,x2,y2, rx,ry, rx+rw,ry);\n     bottom = this.collideLineLine(x1,y1,x2,y2, rx,ry+rh, rx+rw,ry+rh);\n  }\n\n  // if ANY of the above are true, the line has hit the rectangle\n  if (left || right || top || bottom) {\n    if(calcIntersection){\n      return intersection;\n    }\n    return true;\n  }\n  return false;\n}\n\n\np5.prototype.collidePointPoly = function(px, py, vertices) {\n  var collision = false;\n\n  // go through each of the vertices, plus the next vertex in the list\n  var next = 0;\n  for (var current=0; current<vertices.length; current++) {\n\n    // get next vertex in list if we've hit the end, wrap around to 0\n    next = current+1;\n    if (next == vertices.length) next = 0;\n\n    // get the PVectors at our current position this makes our if statement a little cleaner\n    var vc = vertices[current];    // c for \"current\"\n    var vn = vertices[next];       // n for \"next\"\n\n    // compare position, flip 'collision' variable back and forth\n    if (((vc.y > py && vn.y < py) || (vc.y < py && vn.y > py)) &&\n         (px < (vn.x-vc.x)*(py-vc.y) / (vn.y-vc.y)+vc.x)) {\n            collision = !collision;\n    }\n  }\n  return collision;\n}\n\n// POLYGON/CIRCLE\np5.prototype.collideCirclePoly = function(cx, cy, diameter, vertices, interior) {\n\n  if (interior == undefined){\n    interior = false;\n  }\n\n  // go through each of the vertices, plus the next vertex in the list\n  var next = 0;\n  for (var current=0; current<vertices.length; current++) {\n\n    // get next vertex in list if we've hit the end, wrap around to 0\n    next = current+1;\n    if (next == vertices.length) next = 0;\n\n    // get the PVectors at our current position this makes our if statement a little cleaner\n    var vc = vertices[current];    // c for \"current\"\n    var vn = vertices[next];       // n for \"next\"\n\n    // check for collision between the circle and a line formed between the two vertices\n    var collision = this.collideLineCircle(vc.x,vc.y, vn.x,vn.y, cx,cy,diameter);\n    if (collision) return true;\n  }\n\n  // test if the center of the circle is inside the polygon\n  if(interior == true){\n    var centerInside = this.collidePointPoly(cx,cy, vertices);\n    if (centerInside) return true;\n  }\n\n  // otherwise, after all that, return false\n  return false;\n}\n\np5.prototype.collideRectPoly = function( rx, ry, rw, rh, vertices, interior) {\n  if (interior == undefined){\n    interior = false;\n  }\n\n  // go through each of the vertices, plus the next vertex in the list\n  var next = 0;\n  for (var current=0; current<vertices.length; current++) {\n\n    // get next vertex in list if we've hit the end, wrap around to 0\n    next = current+1;\n    if (next == vertices.length) next = 0;\n\n    // get the PVectors at our current position this makes our if statement a little cleaner\n    var vc = vertices[current];    // c for \"current\"\n    var vn = vertices[next];       // n for \"next\"\n\n    // check against all four sides of the rectangle\n    var collision = this.collideLineRect(vc.x,vc.y,vn.x,vn.y, rx,ry,rw,rh);\n    if (collision) return true;\n\n    // optional: test if the rectangle is INSIDE the polygon note that this iterates all sides of the polygon again, so only use this if you need to\n    if(interior == true){\n      var inside = this.collidePointPoly(rx,ry, vertices);\n      if (inside) return true;\n    }\n  }\n\n  return false;\n}\n\np5.prototype.collideLinePoly = function(x1, y1, x2, y2, vertices) {\n\n  // go through each of the vertices, plus the next vertex in the list\n  var next = 0;\n  for (var current=0; current<vertices.length; current++) {\n\n    // get next vertex in list if we've hit the end, wrap around to 0\n    next = current+1;\n    if (next == vertices.length) next = 0;\n\n    // get the PVectors at our current position extract X/Y coordinates from each\n    var x3 = vertices[current].x;\n    var y3 = vertices[current].y;\n    var x4 = vertices[next].x;\n    var y4 = vertices[next].y;\n\n    // do a Line/Line comparison if true, return 'true' immediately and stop testing (faster)\n    var hit = this.collideLineLine(x1, y1, x2, y2, x3, y3, x4, y4);\n    if (hit) {\n      return true;\n    }\n  }\n  // never got a hit\n  return false;\n}\n\np5.prototype.collidePolyPoly = function(p1, p2, interior) {\n  if (interior == undefined){\n    interior = false;\n  }\n\n  // go through each of the vertices, plus the next vertex in the list\n  var next = 0;\n  for (var current=0; current<p1.length; current++) {\n\n    // get next vertex in list, if we've hit the end, wrap around to 0\n    next = current+1;\n    if (next == p1.length) next = 0;\n\n    // get the PVectors at our current position this makes our if statement a little cleaner\n    var vc = p1[current];    // c for \"current\"\n    var vn = p1[next];       // n for \"next\"\n\n    //use these two points (a line) to compare to the other polygon's vertices using polyLine()\n    var collision = this.collideLinePoly(vc.x,vc.y,vn.x,vn.y,p2);\n    if (collision) return true;\n\n    //check if the 2nd polygon is INSIDE the first\n    if(interior == true){\n      collision = this.collidePointPoly(p2[0].x, p2[0].y, p1);\n      if (collision) return true;\n    }\n  }\n\n  return false;\n}\n\np5.prototype.collidePointTriangle = function(px, py, x1, y1, x2, y2, x3, y3) {\n\n  // get the area of the triangle\n  var areaOrig = this.abs( (x2-x1)*(y3-y1) - (x3-x1)*(y2-y1) );\n\n  // get the area of 3 triangles made between the point and the corners of the triangle\n  var area1 =    this.abs( (x1-px)*(y2-py) - (x2-px)*(y1-py) );\n  var area2 =    this.abs( (x2-px)*(y3-py) - (x3-px)*(y2-py) );\n  var area3 =    this.abs( (x3-px)*(y1-py) - (x1-px)*(y3-py) );\n\n  // if the sum of the three areas equals the original, we're inside the triangle!\n  if (area1 + area2 + area3 == areaOrig) {\n    return true;\n  }\n  return false;\n}\n\np5.prototype.collidePointPoint = function (x,y,x2,y2, buffer) {\n    if(buffer == undefined){\n      buffer = 0;\n    }\n\n    if(this.dist(x,y,x2,y2) <= buffer){\n      return true;\n    }\n\n  return false;\n};\n\np5.prototype.collidePointArc = function(px, py, ax, ay, arcRadius, arcHeading, arcAngle, buffer) {\n\n  if (buffer == undefined) {\n    buffer = 0;\n  }\n  // point\n  var point = this.createVector(px, py);\n  // arc center point\n  var arcPos = this.createVector(ax, ay);\n  // arc radius vector\n  var radius = this.createVector(arcRadius, 0).rotate(arcHeading);\n\n  var pointToArc = point.copy().sub(arcPos);\n\n  if (point.dist(arcPos) <= (arcRadius + buffer)) {\n    var dot = radius.dot(pointToArc);\n    var angle = radius.angleBetween(pointToArc);\n    if (dot > 0 && angle <= arcAngle / 2 && angle >= -arcAngle / 2) {\n      return true;\n    }\n  }\n  return false;\n}\n"]}